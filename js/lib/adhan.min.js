/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/adhan@4.3.0/Adhan.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!(function (t, e) {
    'object' == typeof exports && 'object' == typeof module
        ? (module.exports = e())
        : 'function' == typeof define && define.amd
          ? define([], e)
          : 'object' == typeof exports
            ? (exports.adhan = e())
            : (t.adhan = e());
})(this, function () {
    return (function (t) {
        var e = {};
        function n(a) {
            if (e[a]) return e[a].exports;
            var r = (e[a] = { i: a, l: !1, exports: {} });
            return (t[a].call(r.exports, r, r.exports, n), (r.l = !0), r.exports);
        }
        return (
            (n.m = t),
            (n.c = e),
            (n.d = function (t, e, a) {
                n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: a });
            }),
            (n.r = function (t) {
                ('undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
                    Object.defineProperty(t, '__esModule', { value: !0 }));
            }),
            (n.t = function (t, e) {
                if ((1 & e && (t = n(t)), 8 & e)) return t;
                if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
                var a = Object.create(null);
                if ((n.r(a), Object.defineProperty(a, 'default', { enumerable: !0, value: t }), 2 & e && 'string' != typeof t))
                    for (var r in t)
                        n.d(
                            a,
                            r,
                            function (e) {
                                return t[e];
                            }.bind(null, r)
                        );
                return a;
            }),
            (n.n = function (t) {
                var e =
                    t && t.__esModule
                        ? function () {
                              return t.default;
                          }
                        : function () {
                              return t;
                          };
                return (n.d(e, 'a', e), e);
            }),
            (n.o = function (t, e) {
                return Object.prototype.hasOwnProperty.call(t, e);
            }),
            (n.p = ''),
            n((n.s = 0))
        );
    })([
        function (t, e, n) {
            'use strict';
            n.r(e);
            class a {
                constructor(t, e) {
                    ((this.latitude = t), (this.longitude = e));
                }
            }
            function r(t) {
                return (t * Math.PI) / 180;
            }
            function i(t) {
                return (180 * t) / Math.PI;
            }
            function s(t, e) {
                return t - e * Math.floor(t / e);
            }
            function o(t) {
                return s(t, 360);
            }
            const h = { Nearest: 'nearest', Up: 'up', None: 'none' };
            function u(t, e) {
                const n = t.getFullYear(),
                    a = t.getMonth(),
                    r = t.getDate() + e,
                    i = t.getHours(),
                    s = t.getMinutes(),
                    o = t.getSeconds();
                return new Date(n, a, r, i, s, o);
            }
            function l(t, e) {
                return c(t, 60 * e);
            }
            function c(t, e) {
                return new Date(t.getTime() + 1e3 * e);
            }
            function d(t, e = h.Nearest) {
                const n = t.getUTCSeconds();
                let a = n >= 30 ? 60 - n : -1 * n;
                return (e === h.Up ? (a = 60 - n) : e === h.None && (a = 0), c(t, a));
            }
            function g(t) {
                let e = 0;
                const n = [31, w.isLeapYear(t.getFullYear()) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                for (let a = 0; a < t.getMonth(); a++) e += n[a];
                return ((e += t.getDate()), e);
            }
            function m(t) {
                return t instanceof Date && !isNaN(t.valueOf());
            }
            const M = 'general',
                f = 'ahmer',
                p = 'abyad',
                b = {
                    meanSolarLongitude(t) {
                        const e = t;
                        return o(280.4664567 + 36000.76983 * e + 3032e-7 * Math.pow(e, 2));
                    },
                    meanLunarLongitude: (t) => o(218.3165 + 481267.8813 * t),
                    ascendingLunarNodeLongitude(t) {
                        const e = t;
                        return o(125.04452 - 1934.136261 * e + 0.0020708 * Math.pow(e, 2) + Math.pow(e, 3) / 45e4);
                    },
                    meanSolarAnomaly(t) {
                        const e = t;
                        return o(357.52911 + 35999.05029 * e - 1537e-7 * Math.pow(e, 2));
                    },
                    solarEquationOfTheCenter(t, e) {
                        const n = t,
                            a = r(e);
                        return (1.914602 - 0.004817 * n - 14e-6 * Math.pow(n, 2)) * Math.sin(a) + (0.019993 - 101e-6 * n) * Math.sin(2 * a) + 289e-6 * Math.sin(3 * a);
                    },
                    apparentSolarLongitude(t, e) {
                        const n = t,
                            a = 125.04 - 1934.136 * n;
                        return o(e + b.solarEquationOfTheCenter(n, b.meanSolarAnomaly(n)) - 0.00569 - 0.00478 * Math.sin(r(a)));
                    },
                    meanObliquityOfTheEcliptic(t) {
                        const e = t;
                        return 23.439291 - 0.013004167 * e - 1.639e-7 * Math.pow(e, 2) + 5.036e-7 * Math.pow(e, 3);
                    },
                    apparentObliquityOfTheEcliptic(t, e) {
                        const n = 125.04 - 1934.136 * t;
                        return e + 0.00256 * Math.cos(r(n));
                    },
                    meanSiderealTime(t) {
                        const e = t;
                        return o(280.46061837 + 360.98564736629 * (36525 * e + 2451545 - 2451545) + 387933e-9 * Math.pow(e, 2) - Math.pow(e, 3) / 3871e4);
                    },
                    nutationInLongitude(t, e, n, a) {
                        const i = e,
                            s = n,
                            o = a;
                        return (-17.2 / 3600) * Math.sin(r(o)) - (1.32 / 3600) * Math.sin(2 * r(i)) - (0.23 / 3600) * Math.sin(2 * r(s)) + (0.21 / 3600) * Math.sin(2 * r(o));
                    },
                    nutationInObliquity(t, e, n, a) {
                        const i = e,
                            s = n,
                            o = a;
                        return (9.2 / 3600) * Math.cos(r(o)) + (0.57 / 3600) * Math.cos(2 * r(i)) + (0.1 / 3600) * Math.cos(2 * r(s)) - (0.09 / 3600) * Math.cos(2 * r(o));
                    },
                    altitudeOfCelestialBody(t, e, n) {
                        const a = t,
                            s = e,
                            o = n,
                            h = Math.sin(r(a)) * Math.sin(r(s)),
                            u = Math.cos(r(a)) * Math.cos(r(s)) * Math.cos(r(o));
                        return i(Math.asin(h + u));
                    },
                    approximateTransit: (t, e, n) => s((n + -1 * t - e) / 360, 1),
                    correctedTransit(t, e, n, a, r, i) {
                        const s = t,
                            h = a,
                            u = r,
                            l = i,
                            c = -1 * e,
                            d = o(n + 360.985647 * s),
                            g = o(b.interpolateAngles(h, u, l, s));
                        var m;
                        return 24 * (s + ((m = d - c - g) >= -180 && m <= 180 ? m : m - 360 * Math.round(m / 360)) / -360);
                    },
                    correctedHourAngle(t, e, n, a, s, h, u, l, c, d, g) {
                        const m = t,
                            M = e,
                            f = s,
                            p = h,
                            w = u,
                            A = l,
                            T = c,
                            j = d,
                            S = g,
                            v = -1 * n.longitude,
                            y = Math.sin(r(M)) - Math.sin(r(n.latitude)) * Math.sin(r(T)),
                            D = Math.cos(r(n.latitude)) * Math.cos(r(T)),
                            O = i(Math.acos(y / D)),
                            N = a ? m + O / 360 : m - O / 360,
                            L = o(f + 360.985647 * N),
                            x = o(b.interpolateAngles(p, w, A, N)),
                            Y = b.interpolate(T, j, S, N),
                            C = L - v - x;
                        return 24 * (N + (b.altitudeOfCelestialBody(n.latitude, Y, C) - M) / (360 * Math.cos(r(Y)) * Math.cos(r(n.latitude)) * Math.sin(r(C))));
                    },
                    interpolate(t, e, n, a) {
                        const r = t - e,
                            i = n - t;
                        return t + (a / 2) * (r + i + a * (i - r));
                    },
                    interpolateAngles(t, e, n, a) {
                        const r = o(t - e),
                            i = o(n - t);
                        return t + (a / 2) * (r + i + a * (i - r));
                    },
                    julianDay(t, e, n, a) {
                        void 0 === a && (a = 0);
                        const r =
                                Math.trunc ||
                                function (t) {
                                    return t < 0 ? Math.ceil(t) : Math.floor(t);
                                },
                            i = r(e > 2 ? t : t - 1),
                            s = r(e > 2 ? e : e + 12),
                            o = n + a / 24,
                            h = r(i / 100),
                            u = r(2 - h + r(h / 4));
                        return r(365.25 * (i + 4716)) + r(30.6001 * (s + 1)) + o + u - 1524.5;
                    },
                    julianCentury: (t) => (t - 2451545) / 36525,
                    isLeapYear: (t) => t % 4 == 0 && (t % 100 != 0 || t % 400 == 0),
                    seasonAdjustedMorningTwilight(t, e, n, a) {
                        const r = 75 + (28.65 / 55) * Math.abs(t),
                            i = 75 + (19.44 / 55) * Math.abs(t),
                            s = 75 + (32.74 / 55) * Math.abs(t),
                            o = 75 + (48.1 / 55) * Math.abs(t),
                            h = (function () {
                                const a = b.daysSinceSolstice(e, n, t);
                                return a < 91
                                    ? r + ((i - r) / 91) * a
                                    : a < 137
                                      ? i + ((s - i) / 46) * (a - 91)
                                      : a < 183
                                        ? s + ((o - s) / 46) * (a - 137)
                                        : a < 229
                                          ? o + ((s - o) / 46) * (a - 183)
                                          : a < 275
                                            ? s + ((i - s) / 46) * (a - 229)
                                            : i + ((r - i) / 91) * (a - 275);
                            })();
                        return c(a, Math.round(-60 * h));
                    },
                    seasonAdjustedEveningTwilight(t, e, n, a, r) {
                        let i, s, o, h;
                        r === f
                            ? ((i = 62 + (17.4 / 55) * Math.abs(t)),
                              (s = 62 - (7.16 / 55) * Math.abs(t)),
                              (o = 62 + (5.12 / 55) * Math.abs(t)),
                              (h = 62 + (19.44 / 55) * Math.abs(t)))
                            : r === p
                              ? ((i = 75 + (25.6 / 55) * Math.abs(t)), (s = 75 + (7.16 / 55) * Math.abs(t)), (o = 75 + (36.84 / 55) * Math.abs(t)), (h = 75 + 1.488 * Math.abs(t)))
                              : ((i = 75 + (25.6 / 55) * Math.abs(t)),
                                (s = 75 + (2.05 / 55) * Math.abs(t)),
                                (o = 75 - (9.21 / 55) * Math.abs(t)),
                                (h = 75 + (6.14 / 55) * Math.abs(t)));
                        const u = (function () {
                            const a = b.daysSinceSolstice(e, n, t);
                            return a < 91
                                ? i + ((s - i) / 91) * a
                                : a < 137
                                  ? s + ((o - s) / 46) * (a - 91)
                                  : a < 183
                                    ? o + ((h - o) / 46) * (a - 137)
                                    : a < 229
                                      ? h + ((o - h) / 46) * (a - 183)
                                      : a < 275
                                        ? o + ((s - o) / 46) * (a - 229)
                                        : s + ((i - s) / 91) * (a - 275);
                        })();
                        return c(a, Math.round(60 * u));
                    },
                    daysSinceSolstice(t, e, n) {
                        let a = 0;
                        const r = b.isLeapYear(e) ? 173 : 172,
                            i = b.isLeapYear(e) ? 366 : 365;
                        return (n >= 0 ? ((a = t + 10), a >= i && (a -= i)) : ((a = t - r), a < 0 && (a += i)), a);
                    }
                };
            var w = b;
            class A {
                constructor(t) {
                    const e = w.julianCentury(t),
                        n = w.meanSolarLongitude(e),
                        a = w.meanLunarLongitude(e),
                        s = w.ascendingLunarNodeLongitude(e),
                        h = r(w.apparentSolarLongitude(e, n)),
                        u = w.meanSiderealTime(e),
                        l = w.nutationInLongitude(e, n, a, s),
                        c = w.nutationInObliquity(e, n, a, s),
                        d = w.meanObliquityOfTheEcliptic(e),
                        g = r(w.apparentObliquityOfTheEcliptic(e, d));
                    ((this.declination = i(Math.asin(Math.sin(g) * Math.sin(h)))),
                        (this.rightAscension = o(i(Math.atan2(Math.cos(g) * Math.sin(h), Math.cos(h))))),
                        (this.apparentSiderealTime = u + (3600 * l * Math.cos(r(d + c))) / 3600));
                }
            }
            class T {
                constructor(t, e) {
                    const n = w.julianDay(t.getFullYear(), t.getMonth() + 1, t.getDate(), 0);
                    ((this.observer = e), (this.solar = new A(n)), (this.prevSolar = new A(n - 1)), (this.nextSolar = new A(n + 1)));
                    const a = w.approximateTransit(e.longitude, this.solar.apparentSiderealTime, this.solar.rightAscension),
                        r = -50 / 60;
                    ((this.approxTransit = a),
                        (this.transit = w.correctedTransit(
                            a,
                            e.longitude,
                            this.solar.apparentSiderealTime,
                            this.solar.rightAscension,
                            this.prevSolar.rightAscension,
                            this.nextSolar.rightAscension
                        )),
                        (this.sunrise = w.correctedHourAngle(
                            a,
                            r,
                            e,
                            !1,
                            this.solar.apparentSiderealTime,
                            this.solar.rightAscension,
                            this.prevSolar.rightAscension,
                            this.nextSolar.rightAscension,
                            this.solar.declination,
                            this.prevSolar.declination,
                            this.nextSolar.declination
                        )),
                        (this.sunset = w.correctedHourAngle(
                            a,
                            r,
                            e,
                            !0,
                            this.solar.apparentSiderealTime,
                            this.solar.rightAscension,
                            this.prevSolar.rightAscension,
                            this.nextSolar.rightAscension,
                            this.solar.declination,
                            this.prevSolar.declination,
                            this.nextSolar.declination
                        )));
                }
                hourAngle(t, e) {
                    return w.correctedHourAngle(
                        this.approxTransit,
                        t,
                        this.observer,
                        e,
                        this.solar.apparentSiderealTime,
                        this.solar.rightAscension,
                        this.prevSolar.rightAscension,
                        this.nextSolar.rightAscension,
                        this.solar.declination,
                        this.prevSolar.declination,
                        this.nextSolar.declination
                    );
                }
                afternoon(t) {
                    const e = Math.abs(this.observer.latitude - this.solar.declination),
                        n = t + Math.tan(r(e)),
                        a = i(Math.atan(1 / n));
                    return this.hourAngle(a, !0);
                }
            }
            class j {
                constructor(t) {
                    return (
                        (this.hours = Math.floor(t)),
                        (this.minutes = Math.floor(60 * (t - this.hours))),
                        (this.seconds = Math.floor(60 * (t - (this.hours + this.minutes / 60)) * 60)),
                        this
                    );
                }
                utcDate(t, e, n) {
                    return new Date(Date.UTC(t, e, n, this.hours, this.minutes, this.seconds));
                }
            }
            var S = { Fajr: 'fajr', Sunrise: 'sunrise', Dhuhr: 'dhuhr', Asr: 'asr', Maghrib: 'maghrib', Isha: 'isha', None: 'none' };
            const v = { Shafi: 'shafi', Hanafi: 'hanafi' };
            const y = { AqrabBalad: 'AqrabBalad', AqrabYaum: 'AqrabYaum', Unresolved: 'Unresolved' },
                D = (t) => t && !isNaN(t.sunrise) && !isNaN(t.sunset),
                O = (t, e, n = 1, a = 1) => {
                    if (n > Math.ceil(182.5)) return null;
                    const r = new Date(e.getTime());
                    r.setDate(r.getDate() + a * n);
                    const i = u(r, 1),
                        s = new T(r, t),
                        o = new T(i, t);
                    return D(s) && D(o) ? { date: e, tomorrow: i, coordinates: t, solarTime: s, tomorrowSolarTime: o } : O(t, e, n + (a > 0 ? 0 : 1), -a);
                },
                N = (t, e, n) => {
                    const a = new T(e, { ...t, latitude: n }),
                        r = u(e, 1),
                        i = new T(r, { ...t, latitude: n });
                    return D(a) && D(i)
                        ? { date: e, tomorrow: r, coordinates: { latitude: n, longitude: t.longitude }, solarTime: a, tomorrowSolarTime: i }
                        : Math.abs(n) >= 65
                          ? N(t, e, n - 0.5 * Math.sign(n))
                          : null;
                };
            class L {
                constructor(t, e, n) {
                    ((this.coordinates = t), (this.date = e), (this.calculationParameters = n));
                    let a,
                        r,
                        i,
                        s,
                        o,
                        h,
                        M,
                        f = new T(e, t);
                    ((i = new j(f.transit).utcDate(e.getFullYear(), e.getMonth(), e.getDate())), (r = new j(f.sunrise).utcDate(e.getFullYear(), e.getMonth(), e.getDate())));
                    let p = new j(f.sunset).utcDate(e.getFullYear(), e.getMonth(), e.getDate()),
                        b = u(e, 1),
                        A = new T(b, t);
                    const S = n.polarCircleResolution;
                    if ((!m(r) || !m(p) || isNaN(A.sunrise)) && S !== y.Unresolved) {
                        const n = ((t, e, n) => {
                            const a = { date: e, tomorrow: u(e, 1), coordinates: n, solarTime: new T(e, n), tomorrowSolarTime: new T(u(e, 1), n) };
                            switch (t) {
                                case y.AqrabYaum:
                                    return O(n, e) || a;
                                case y.AqrabBalad: {
                                    const { latitude: t } = n;
                                    return N(n, e, t - 0.5 * Math.sign(t)) || a;
                                }
                                default:
                                    return a;
                            }
                        })(S, e, t);
                        ((this.coordinates = n.coordinates), this.date.setTime(n.date.getTime()), (f = n.solarTime), (b = n.tomorrow), (A = n.tomorrowSolarTime));
                        const a = [e.getFullYear(), e.getMonth(), e.getDate()];
                        ((i = new j(f.transit).utcDate(...a)), (r = new j(f.sunrise).utcDate(...a)), (p = new j(f.sunset).utcDate(...a)));
                    }
                    s = new j(
                        f.afternoon(
                            (function (t) {
                                switch (t) {
                                    case v.Shafi:
                                        return 1;
                                    case v.Hanafi:
                                        return 2;
                                    default:
                                        throw 'Invalid Madhab';
                                }
                            })(n.madhab)
                        )
                    ).utcDate(e.getFullYear(), e.getMonth(), e.getDate());
                    const D = (new j(A.sunrise).utcDate(b.getFullYear(), b.getMonth(), b.getDate()) - p) / 1e3;
                    ((a = new j(f.hourAngle(-1 * n.fajrAngle, !1)).utcDate(e.getFullYear(), e.getMonth(), e.getDate())),
                        'MoonsightingCommittee' === n.method && t.latitude >= 55 && ((M = D / 7), (a = c(r, -M))));
                    const L = (function () {
                        if ('MoonsightingCommittee' === n.method) return w.seasonAdjustedMorningTwilight(t.latitude, g(e), e.getFullYear(), r);
                        {
                            const t = n.nightPortions().fajr;
                            return ((M = t * D), c(r, -M));
                        }
                    })();
                    if (((null === a || isNaN(a.getTime()) || L > a) && (a = L), n.ishaInterval > 0)) h = l(p, n.ishaInterval);
                    else {
                        ((h = new j(f.hourAngle(-1 * n.ishaAngle, !0)).utcDate(e.getFullYear(), e.getMonth(), e.getDate())),
                            'MoonsightingCommittee' === n.method && t.latitude >= 55 && ((M = D / 7), (h = c(p, M))));
                        const a = (function () {
                            if ('MoonsightingCommittee' === n.method) return w.seasonAdjustedEveningTwilight(t.latitude, g(e), e.getFullYear(), p, n.shafaq);
                            {
                                const t = n.nightPortions().isha;
                                return ((M = t * D), c(p, M));
                            }
                        })();
                        (null == h || isNaN(h.getTime()) || a < h) && (h = a);
                    }
                    if (((o = p), n.maghribAngle)) {
                        const t = new j(f.hourAngle(-1 * n.maghribAngle, !0)).utcDate(e.getFullYear(), e.getMonth(), e.getDate());
                        p < t && h > t && (o = t);
                    }
                    const x = (n.adjustments.fajr || 0) + (n.methodAdjustments.fajr || 0),
                        Y = (n.adjustments.sunrise || 0) + (n.methodAdjustments.sunrise || 0),
                        C = (n.adjustments.dhuhr || 0) + (n.methodAdjustments.dhuhr || 0),
                        F = (n.adjustments.asr || 0) + (n.methodAdjustments.asr || 0),
                        P = (n.adjustments.maghrib || 0) + (n.methodAdjustments.maghrib || 0),
                        q = (n.adjustments.isha || 0) + (n.methodAdjustments.isha || 0);
                    ((this.fajr = d(l(a, x), n.rounding)),
                        (this.sunrise = d(l(r, Y), n.rounding)),
                        (this.dhuhr = d(l(i, C), n.rounding)),
                        (this.asr = d(l(s, F), n.rounding)),
                        (this.maghrib = d(l(o, P), n.rounding)),
                        (this.isha = d(l(h, q), n.rounding)));
                }
                timeForPrayer(t) {
                    return t === S.Fajr
                        ? this.fajr
                        : t === S.Sunrise
                          ? this.sunrise
                          : t === S.Dhuhr
                            ? this.dhuhr
                            : t === S.Asr
                              ? this.asr
                              : t === S.Maghrib
                                ? this.maghrib
                                : t === S.Isha
                                  ? this.isha
                                  : null;
                }
                currentPrayer(t) {
                    return (
                        void 0 === t && (t = new Date()),
                        t >= this.isha
                            ? S.Isha
                            : t >= this.maghrib
                              ? S.Maghrib
                              : t >= this.asr
                                ? S.Asr
                                : t >= this.dhuhr
                                  ? S.Dhuhr
                                  : t >= this.sunrise
                                    ? S.Sunrise
                                    : t >= this.fajr
                                      ? S.Fajr
                                      : S.None
                    );
                }
                nextPrayer(t) {
                    return (
                        void 0 === t && (t = new Date()),
                        t >= this.isha
                            ? S.None
                            : t >= this.maghrib
                              ? S.Isha
                              : t >= this.asr
                                ? S.Maghrib
                                : t >= this.dhuhr
                                  ? S.Asr
                                  : t >= this.sunrise
                                    ? S.Dhuhr
                                    : t >= this.fajr
                                      ? S.Sunrise
                                      : S.Fajr
                    );
                }
            }
            const x = {
                MiddleOfTheNight: 'middleofthenight',
                SeventhOfTheNight: 'seventhofthenight',
                TwilightAngle: 'twilightangle',
                recommended: (t) => (t.latitude > 48 ? x.SeventhOfTheNight : x.MiddleOfTheNight)
            };
            var Y = x;
            class C {
                constructor(t, e, n, a, r) {
                    ((this.method = t || 'Other'),
                        (this.fajrAngle = e || 0),
                        (this.ishaAngle = n || 0),
                        (this.ishaInterval = a || 0),
                        (this.maghribAngle = r),
                        (this.madhab = v.Shafi),
                        (this.highLatitudeRule = Y.MiddleOfTheNight),
                        (this.adjustments = { fajr: 0, sunrise: 0, dhuhr: 0, asr: 0, maghrib: 0, isha: 0 }),
                        (this.methodAdjustments = { fajr: 0, sunrise: 0, dhuhr: 0, asr: 0, maghrib: 0, isha: 0 }),
                        (this.polarCircleResolution = y.Unresolved),
                        (this.rounding = h.Nearest),
                        (this.shafaq = M));
                }
                nightPortions() {
                    switch (this.highLatitudeRule) {
                        case Y.MiddleOfTheNight:
                            return { fajr: 0.5, isha: 0.5 };
                        case Y.SeventhOfTheNight:
                            return { fajr: 1 / 7, isha: 1 / 7 };
                        case Y.TwilightAngle:
                            return { fajr: this.fajrAngle / 60, isha: this.ishaAngle / 60 };
                        default:
                            throw `Invalid high latitude rule found when attempting to compute night portions: ${this.highLatitudeRule}`;
                    }
                }
            }
            var F = {
                MuslimWorldLeague() {
                    const t = new C('MuslimWorldLeague', 18, 17);
                    return ((t.methodAdjustments = { dhuhr: 1 }), t);
                },
                Egyptian() {
                    const t = new C('Egyptian', 19.5, 17.5);
                    return ((t.methodAdjustments = { dhuhr: 1 }), t);
                },
                Karachi() {
                    const t = new C('Karachi', 18, 18);
                    return ((t.methodAdjustments = { dhuhr: 1 }), t);
                },
                UmmAlQura: () => new C('UmmAlQura', 18.5, 0, 90),
                Dubai() {
                    const t = new C('Dubai', 18.2, 18.2);
                    return ((t.methodAdjustments = { sunrise: -3, dhuhr: 3, asr: 3, maghrib: 3 }), t);
                },
                MoonsightingCommittee() {
                    const t = new C('MoonsightingCommittee', 18, 18);
                    return ((t.methodAdjustments = { dhuhr: 5, maghrib: 3 }), t);
                },
                NorthAmerica() {
                    const t = new C('NorthAmerica', 15, 15);
                    return ((t.methodAdjustments = { dhuhr: 1 }), t);
                },
                Kuwait: () => new C('Kuwait', 18, 17.5),
                Qatar: () => new C('Qatar', 18, 0, 90),
                Singapore() {
                    const t = new C('Singapore', 20, 18);
                    return ((t.methodAdjustments = { dhuhr: 1 }), (t.rounding = h.Up), t);
                },
                Tehran: () => new C('Tehran', 17.7, 14, 0, 4.5),
                Turkey() {
                    const t = new C('Turkey', 18, 17);
                    return ((t.methodAdjustments = { sunrise: -7, dhuhr: 5, asr: 4, maghrib: 7 }), t);
                },
                Other: () => new C('Other', 0, 0)
            };
            const P = {
                Prayer: S,
                Madhab: v,
                HighLatitudeRule: Y,
                Coordinates: a,
                CalculationParameters: C,
                CalculationMethod: F,
                PrayerTimes: L,
                SunnahTimes: class {
                    constructor(t) {
                        const e = u(t.date, 1),
                            n = (new L(t.coordinates, e, t.calculationParameters).fajr.getTime() - t.maghrib.getTime()) / 1e3;
                        ((this.middleOfTheNight = d(c(t.maghrib, n / 2))), (this.lastThirdOfTheNight = d(c(t.maghrib, n * (2 / 3)))));
                    }
                },
                Qibla: function (t) {
                    const e = new a(21.4225241, 39.8261818),
                        n = Math.sin(r(e.longitude) - r(t.longitude)),
                        s = Math.cos(r(t.latitude)) * Math.tan(r(e.latitude)),
                        h = Math.sin(r(t.latitude)) * Math.cos(r(e.longitude) - r(t.longitude));
                    return o(i(Math.atan2(n, s - h)));
                },
                PolarCircleResolution: y,
                Rounding: h
            };
            e.default = P;
        }
    ]).default;
});
//# sourceMappingURL=/sm/d96d9fc91a877063ea219707e07fe16f955f5424e183ae7ab9046ab5d7d521de.map
